-- lua/ge/extensions/PropHunt.lua
local M = {}

-- --- CONFIG ---
local TAUNT_INTERVAL = 30
local TAUNT_SOUND_DISTANCE = 50 -- how far taunts can be heard (reduced from 150)
local FLASH_SOUND_DISTANCE = 300 -- how far flashbangs can be heard
local FLASH_COOLDOWN = 15 -- cooldown in seconds between flashbang uses

local SOUND_VOLUME = 1
local MAX_SOUND_LENGTH = 10

-- --- STATE ---
local runnerID = nil
local propID = nil
local isHidden = false
local tauntTimer = 0
local uiTimer = 0
local activeEmitters = {}
local flashCooldownTimer = 0 -- tracks time since last flashbang

-- --- GAME STATE ---
local playerTeam = nil -- "seeker" or "hider"
local gameActive = false
local gameTimer = 0
local lastGameTimer = 0 -- track previous timer value for notifications
local hidePhase = false -- True during 20-second hide countdown
local hideTimer = 0

-- Round identity (server-sent) + idempotency
local currentRoundId = nil

-- Disguise gating: only allow prop transform after hide phase ends / round starts
local allowDisguise = false
local disguisedThisRound = false
local disguisedRoundId = nil

-- Forward declarations for network handlers
local onNetworkTaunt
local onNetworkFlashSound
local onGameStart
local onGameEnd
local onTimerUpdate
local onHidePhaseStart
local onHideTimerUpdate
local onHidePhaseEnd
local onRoundStart
local onRoundEnd
local onPlayerEliminated
local onAssignProp
local onChatMessage

local function onExtensionLoaded()
    print("DEBUG: PropHunt Core LOADED.")

    -- Ensure PropHuntFlash extension is loaded
    if not extensions.PropHuntFlash then
        local ok, err = pcall(function() extensions.load("PropHuntFlash") end)
        if ok then
            print("DEBUG: PropHuntFlash extension loaded successfully")
        else
            print("ERROR: Failed to load PropHuntFlash: " .. tostring(err))
        end
    end

    -- Register network event handlers
    -- NOTE: In some BeamMP builds, MPGameNetwork may not be present in GE Lua.
    -- The actual event system is exposed via AddEventHandler/TriggerServerEvent.
    if AddEventHandler then
        AddEventHandler("PropHunt_Taunt", onNetworkTaunt)
        print("DEBUG: Registered handler for PropHunt_Taunt")
        AddEventHandler("PropHunt_Flashbang", onNetworkFlashSound)
        print("DEBUG: Registered handler for PropHunt_Flashbang")

        -- Register game state handlers
        AddEventHandler("PropHunt_GameStart", onGameStart)
        print("DEBUG: Registered handler for PropHunt_GameStart")
        AddEventHandler("PropHunt_GameEnd", onGameEnd)
        print("DEBUG: Registered handler for PropHunt_GameEnd")
        AddEventHandler("PropHunt_TimerUpdate", onTimerUpdate)
        print("DEBUG: Registered handler for PropHunt_TimerUpdate")
        AddEventHandler("PropHunt_HidePhaseStart", onHidePhaseStart)
        print("DEBUG: Registered handler for PropHunt_HidePhaseStart")
        AddEventHandler("PropHunt_HideTimerUpdate", onHideTimerUpdate)
        print("DEBUG: Registered handler for PropHunt_HideTimerUpdate")
        AddEventHandler("PropHunt_HidePhaseEnd", onHidePhaseEnd)
        print("DEBUG: Registered handler for PropHunt_HidePhaseEnd")
        AddEventHandler("PropHunt_RoundStart", onRoundStart)
        print("DEBUG: Registered handler for PropHunt_RoundStart")
        AddEventHandler("PropHunt_RoundEnd", onRoundEnd)
        print("DEBUG: Registered handler for PropHunt_RoundEnd")

        AddEventHandler("PropHunt_PlayerEliminated", onPlayerEliminated)
        print("DEBUG: Registered handler for PropHunt_PlayerEliminated")

        AddEventHandler("PropHunt_AssignProp", onAssignProp)
        print("DEBUG: Registered handler for PropHunt_AssignProp")

        -- Register chat command handler
        AddEventHandler("ChatMessageReceived", onChatMessage)
        print("DEBUG: Registered PropHunt chat command handler")

        -- Tell server we're ready and request current state (fixes late-load / missed events)
        if TriggerServerEvent then
            TriggerServerEvent("PropHunt_clientReady", "")
            TriggerServerEvent("PropHunt_requestState", "")
        end
    else
        print("ERROR: AddEventHandler not available - BeamMP client events cannot be registered")
    end
end

-- --- AUDIO SYSTEM ---
local function playSound(filename, vehID, maxDistance)
    -- Remove old emitter if exists
    if activeEmitters[vehID] then
        local oldEmitter = scenetree.findObjectById(activeEmitters[vehID].id)
        if oldEmitter then oldEmitter:delete() end
        activeEmitters[vehID] = nil
    end

    local veh = be:getObjectByID(vehID)
    local pos

    if not veh then
        -- If source vehicle doesn't exist (MP sync issue), play at player position
        print("DEBUG: Source vehicle " .. vehID .. " not found, playing sound at player position")
        local playerVeh = be:getPlayerVehicle(0)
        if not playerVeh then return end
        pos = playerVeh:getPosition()
    else
        pos = veh:getPosition()
    end

    -- Use provided distance or default to taunt distance
    local soundDistance = maxDistance or TAUNT_SOUND_DISTANCE

    local newObj = createObject('SFXEmitter')
    newObj:setPosition(pos)
    newObj:setField('filename', 0, filename)
    newObj:setField('playOnAdd', 0, "1")
    newObj:setField('isLooping', 0, "0")
    newObj:setField('maxDistance', 0, tostring(soundDistance))
    newObj:setField('volume', 0, tostring(SOUND_VOLUME))
    newObj.canSave = false
    newObj:registerObject("PropHunt_SFX_"..vehID)

    local grp = scenetree.MissionGroup
    if grp then grp:addObject(newObj) end
    activeEmitters[vehID] = { id = newObj:getID(), timer = MAX_SOUND_LENGTH }
end


-- --- RUNNER SET FUNCTION ---
local function setRunner()
    local veh = be:getPlayerVehicle(0)
    if not veh then return end

    runnerID = veh:getID()
    isHidden = false
    tauntTimer = 0

    guihooks.trigger('Message', {
        msg = "PropHunt: Runner Set!",
        ttl = 2,
        icon = 'directions_car'
    })
end

-- --- PROP SET FUNCTION ---
local function setProp()
    local veh = be:getPlayerVehicle(0)
    if not veh then return end

    propID = veh:getID()

    guihooks.trigger('Message',{
        msg = "PropHunt: Prop Set!",
        ttl = 2,
        icon = 'local_shipping'
    })
end

-- --- SWAP VEHICLES ---
local function performSwap()
    if not runnerID or not propID then
        guihooks.trigger('Message',{
            msg = "Error: Set both vehicles first!",
            ttl = 3,
            icon = 'error'
        })
        return
    end

    local vRunner = be:getObjectByID(runnerID)
    local vProp = be:getObjectByID(propID)

    -- If either vehicle is missing, return silently like the old version
    if not vRunner or not vProp then
        print("DEBUG: One or both vehicles not found (IDs may have changed after reset)")
        guihooks.trigger('Message',{
            msg = "Error: One or both vehicles not found. Please re-set them.",
            ttl = 3,
            icon = 'error'
        })
        return
    end

    -- swap positions
    local posRunner = vRunner:getPosition()
    local rotRunner = vRunner:getRotation()
    local posProp = vProp:getPosition()
    local rotProp = vProp:getRotation()

    vRunner:setPositionRotation(posProp.x,posProp.y,posProp.z,rotProp.x,rotProp.y,rotProp.z,rotProp.w)
    vProp:setPositionRotation(posRunner.x,posRunner.y,posRunner.z,rotRunner.x,rotRunner.y,rotRunner.z,rotRunner.w)

    vRunner:queueLuaCommand("obj:requestReset(RESET_PHYSICS)")
    vProp:queueLuaCommand("obj:requestReset(RESET_PHYSICS)")

    isHidden = not isHidden
    tauntTimer = TAUNT_INTERVAL

    if isHidden then
        be:enterVehicle(0, vProp)
    else
        be:enterVehicle(0, vRunner)
    end

    -- IMPORTANT: Update stored IDs after entering the vehicle
    -- The physics reset and vehicle enter may have changed the vehicle IDs
    -- We need to get the fresh IDs after all operations complete
    local finalVeh = be:getPlayerVehicle(0)
    if finalVeh then
        local finalID = finalVeh:getID()
        if isHidden then
            -- We're now in the prop, update prop ID
            propID = finalID
            print("DEBUG: Updated propID to " .. finalID .. " after swap")
        else
            -- We're now in the runner, update runner ID
            runnerID = finalID
            print("DEBUG: Updated runnerID to " .. finalID .. " after swap")
        end
    end
end

-- --- TAUNT ---
local function triggerTaunt()
    if not propID then return end
    local veh = be:getObjectByID(propID)
    if not veh then return end

    -- LOCAL SOUND
    local selectedSound = "art/Sounds/Taunts/clown.ogg"
    veh:queueLuaCommand("electrics.values.phTaunt = '" .. selectedSound .. "'")

    -- NETWORK SOUND
    if MPCoreNetwork and MPCoreNetwork.isMPSession() and TriggerServerEvent then
        TriggerServerEvent("PropHunt_TauntRequest", tostring(propID))
    end
end

local function manualTaunt()
    triggerTaunt()
    tauntTimer = TAUNT_INTERVAL
end



-- --- FLASHBANG SOUND (mirrors taunt pipeline, but uses flash.ogg) ---
local function manualFlashSound(optionalVehID)
    -- Check cooldown
    if flashCooldownTimer > 0 then
        guihooks.trigger('Message', {
            msg = string.format("Flashbang on cooldown: %.1fs remaining", flashCooldownTimer),
            ttl = 2,
            icon = 'timer'
        })
        print("DEBUG: Flashbang on cooldown: " .. string.format("%.1f", flashCooldownTimer) .. "s remaining")
        return
    end

    -- Use passed vehID if given, otherwise use the player's current vehicle
    local veh = nil
    local vehID = optionalVehID

    if vehID and type(vehID) == 'number' then
        veh = be:getObjectByID(vehID)
    end

    if not veh then
        veh = be:getPlayerVehicle(0)
        if not veh then return end
        vehID = veh:getID()
    end

    -- Reset cooldown timer
    flashCooldownTimer = FLASH_COOLDOWN

    -- Local: play flashbang sound at this vehicle (with 300 unit range)
    local selectedSound = "art/Sounds/Taunts/flash.ogg"
    playSound(selectedSound, vehID, FLASH_SOUND_DISTANCE)

    -- Multiplayer: notify server so other clients can hear it
    if MPCoreNetwork and MPCoreNetwork.isMPSession() then
        print("DEBUG: In multiplayer session, sending flashbang request for vehicle " .. vehID)
        if TriggerServerEvent then
            -- Just send vehicle ID - position will be sent via separate mechanism
            TriggerServerEvent("PropHunt_FlashbangRequest", tostring(vehID))
            print("DEBUG: PropHunt_FlashbangRequest sent to server")
        else
            print("ERROR: TriggerServerEvent function not available!")
        end
    else
        print("DEBUG: Not in multiplayer session (MPCoreNetwork check failed)")
    end
end

-- --- UPDATE LOOP ---
local function onUpdate(dt)
    -- FLASHBANG COOLDOWN
    if flashCooldownTimer > 0 then
        flashCooldownTimer = flashCooldownTimer - dt
        if flashCooldownTimer < 0 then
            flashCooldownTimer = 0
        end
    end

    -- VEHICLE ID VALIDATION - Check if stored vehicle IDs are still valid after resets
    -- This handles the case where a vehicle is fully reset (destroyed and recreated with new ID)
    if runnerID or propID then
        local playerVeh = be:getPlayerVehicle(0)

        if playerVeh then
            local currentID = playerVeh:getID()

            -- Check if stored runner vehicle still exists
            if runnerID then
                local vRunner = be:getObjectByID(runnerID)
                if not vRunner then
                    -- Runner vehicle object no longer exists (was reset)
                    -- If we're currently in a vehicle that's not the prop ID, update runner
                    if currentID ~= propID then
                        print("DEBUG: Runner vehicle ID changed from " .. runnerID .. " to " .. currentID)
                        runnerID = currentID
                        guihooks.trigger('Message', {
                            msg = "Runner vehicle auto-recovered",
                            ttl = 2,
                            icon = 'info'
                        })
                    end
                end
            end

            -- Check if stored prop vehicle still exists
            if propID then
                local vProp = be:getObjectByID(propID)
                if not vProp then
                    -- Prop vehicle object no longer exists (was reset)
                    -- If we're currently in a vehicle that's not the runner ID, update prop
                    if currentID ~= runnerID then
                        print("DEBUG: Prop vehicle ID changed from " .. propID .. " to " .. currentID)
                        propID = currentID
                        guihooks.trigger('Message', {
                            msg = "Prop vehicle auto-recovered",
                            ttl = 2,
                            icon = 'info'
                        })
                    end
                end
            end
        end
    end

    -- AUTO TAUNT
    -- Keep nametags hidden for seeker throughout the round (some builds re-enable them)
    if gameActive and playerTeam == "seeker" and MPVehicleGE and MPVehicleGE.hideNicknames then
        MPVehicleGE.hideNicknames(true)
    end

    if isHidden and propID then
        tauntTimer = tauntTimer - dt
        if tauntTimer <= 0 then
            triggerTaunt()
            tauntTimer = TAUNT_INTERVAL
        end

        -- Reset electrics a moment later so sound doesn't loop incorrectly
        if tauntTimer < (TAUNT_INTERVAL - 2) and tauntTimer > (TAUNT_INTERVAL - 2.2) then
            local veh = be:getObjectByID(propID)
            if veh then
                veh:queueLuaCommand("electrics.values.phTaunt = ''")
            end
        end
    end

    -- UPDATE ACTIVE SOUND EMITTERS
    for vid, data in pairs(activeEmitters) do
        local emitter = scenetree.findObjectById(data.id)
        if emitter then
            data.timer = data.timer - dt
            if data.timer <= 0 then
                emitter:delete()
                activeEmitters[vid] = nil
            else
                local veh = be:getObjectByID(vid)
                if veh then emitter:setPosition(veh:getPosition()) end
            end
        else
            activeEmitters[vid] = nil
        end
    end

    -- E) (legacy) attached prop syncing no longer used; disguise is via replaceVehicle(prop)

    -- UPDATE UI
    uiTimer = uiTimer + dt
    if uiTimer > 0.1 then
        uiTimer = 0
        guihooks.trigger('PropHuntUpdate',{
            isHidden = isHidden,
            timer = tauntTimer,
            runnerSet = (runnerID ~= nil),
            propSet = (propID ~= nil),
            gameActive = gameActive,
            gameTimer = gameTimer,
            playerTeam = playerTeam,
            hidePhase = hidePhase,
            hideTimer = hideTimer
        })
    end
end



-- --- NETWORK HANDLERS (Taunt + Flash sound) ---
onNetworkTaunt = function(data)
    local vehID = tonumber(data)
    if not vehID then return end

    -- Don't double-taunt the owner
    local playerVeh = be:getPlayerVehicle(0)
    if playerVeh and playerVeh:getID() == vehID then return end

    -- Play taunt for remote players
    local selectedSound = "art/Sounds/Taunts/clown.ogg"
    playSound(selectedSound, vehID)
end

onNetworkFlashSound = function(data)
    -- Parse data: "sourcePlayerID,vehID"
    local parts = {}
    for part in string.gmatch(data, "[^,]+") do
        table.insert(parts, part)
    end

    local sourcePlayerID = tonumber(parts[1])
    local vehID = tonumber(parts[2])

    if not sourcePlayerID or not vehID then
        print("ERROR: Invalid flashbang data format: " .. tostring(data))
        return
    end

    print("DEBUG: PropHunt.onNetworkFlashSound received - sourcePlayer: " .. tostring(sourcePlayerID) .. ", veh: " .. vehID)

    -- Don't double-play on the source client; they already played it locally
    local playerVeh = be:getPlayerVehicle(0)
    if playerVeh and playerVeh:getID() == vehID then
        print("DEBUG: Skipping own flashbang (already played locally)")
        return
    end

    -- Play flashbang sound for remote players (with 300 unit range)
    local selectedSound = "art/Sounds/Taunts/flash.ogg"
    playSound(selectedSound, vehID, FLASH_SOUND_DISTANCE)

    -- ALSO trigger visual flash effect for remote players
    if extensions.PropHuntFlash and extensions.PropHuntFlash.handleFlashbang then
        print("DEBUG: Calling PropHuntFlash.handleFlashbang with sourcePlayerID: " .. sourcePlayerID)
        extensions.PropHuntFlash.handleFlashbang(vehID, sourcePlayerID)
    else
        print("ERROR: PropHuntFlash extension not found or handleFlashbang missing!")
    end
end

-- NOTE: Network handlers are now registered in onExtensionLoaded() above

-- --- GAME STATE HANDLERS ---

local function formatMMSS(total)
    total = math.max(0, tonumber(total) or 0)
    local m = math.floor(total / 60)
    local s = math.floor(total % 60)
    return string.format("%d:%02d", m, s)
end

local function showRoundHud(text)
    -- mimic outbreak-style HUD message (1s TTL, stable key)
    if guihooks and guihooks.message then
        guihooks.message({txt = text}, 1, "prophunt.time")
    end
end

onGameStart = function(data)
    -- data: "roundId,team" (new) or just "team" (legacy)
    local roundStr, team = tostring(data or ""):match("^%s*(%d+)%s*,%s*(%w+)%s*$")
    if not team then
        team = tostring(data or "")
    end
    if roundStr then currentRoundId = tonumber(roundStr) end

    playerTeam = team
    gameActive = true
    gameTimer = 300
    lastGameTimer = 300 -- reset timer tracking
    disguisedThisRound = false
    disguisedRoundId = nil

    -- Tell vehicle-side auto extension to start collision checks
    be:queueAllObjectLua("if extensions and extensions.auto_prophunt and extensions.auto_prophunt.setGameRunning then extensions.auto_prophunt.setGameRunning(true) end")

    if team == "seeker" then
        -- Hide nametags for seekers only (apply immediately + delayed to beat BeamMP UI refresh)
        if MPVehicleGE and MPVehicleGE.hideNicknames then
            MPVehicleGE.hideNicknames(true)
            if scheduler and scheduler.add then
                local t = 0
                scheduler.add(function(dt)
                    t = t + dt
                    if t > 1.0 then
                        MPVehicleGE.hideNicknames(true)
                        return false
                    end
                    return true
                end)
            end
        end

        guihooks.trigger('Message', {
            msg = "You are a SEEKER! Find and tag the hiders!",
            ttl = 5,
            icon = 'visibility'
        })
        print("DEBUG: You are a SEEKER")
    else
        -- Ensure hiders can still see nametags
        if MPVehicleGE and MPVehicleGE.hideNicknames then
            MPVehicleGE.hideNicknames(false)
        end

        guihooks.trigger('Message', {
            msg = "You are a HIDER! Hide and survive for 5 minutes!",
            ttl = 5,
            icon = 'visibility_off'
        })
        print("DEBUG: You are a HIDER")

        -- E) Do NOT disguise on game start.
        -- We wait until hide phase ends so hiders can drive to a hiding spot first.
        -- (Disguise will be applied in onHidePhaseEnd.)
    end
end

onGameEnd = function(data)
    -- data may contain a reason/winner string from server (timeout/seekers/manual/etc)
    local reason = tostring(data or "")

    playerTeam = nil
    gameActive = false
    disguisedThisRound = false
    disguisedRoundId = nil
    gameTimer = 0
    lastGameTimer = 0 -- reset timer tracking
    hidePhase = false
    hideTimer = 0
    allowDisguise = false

    -- Restore nametags
    if MPVehicleGE and MPVehicleGE.hideNicknames then
        MPVehicleGE.hideNicknames(false)
    end

    -- Stop collision checks
    be:queueAllObjectLua("if extensions and extensions.auto_prophunt and extensions.auto_prophunt.setGameRunning then extensions.auto_prophunt.setGameRunning(false) end")

    local msg = "Game Over!"
    if reason ~= "" then
        if reason == "timeout" or reason == "hiders" then
            msg = "Round Over: Hiders win!"
        elseif reason == "seekers" then
            msg = "Round Over: Seekers win!"
        elseif reason == "manual" then
            msg = "Round Over: Stopped"
        else
            msg = "Round Over: " .. reason
        end
    end

    guihooks.trigger('Message', {
        msg = msg,
        ttl = 4,
        icon = 'flag'
    })
    print("DEBUG: Game ended (" .. reason .. ")")
end

onTimerUpdate = function(data)
    local roundStr, secStr = tostring(data or ""):match("^%s*(%d+)%s*,%s*(%d+)%s*$")
    if roundStr then currentRoundId = tonumber(roundStr) end
    local newTimer = tonumber(secStr) or tonumber(data) or 0
    showRoundHud("TIME LEFT: " .. formatMMSS(newTimer))

    -- Check for timer milestones and show notifications (only during main round, not hide phase)
    if gameActive and not hidePhase then
        -- Minute updates
        if lastGameTimer > 60 and newTimer <= 60 then
            guihooks.trigger('Message', {
                msg = "1 minute remaining!",
                ttl = 3,
                icon = 'timer'
            })
        end

        -- 30 seconds remaining
        if lastGameTimer > 30 and newTimer <= 30 then
            guihooks.trigger('Message', {
                msg = "30 seconds remaining!",
                ttl = 3,
                icon = 'warning'
            })
        end

        -- Final countdown (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
        if newTimer >= 1 and newTimer <= 10 and lastGameTimer > newTimer then
            guihooks.trigger('Message', {
                msg = tostring(newTimer),
                ttl = 1,
                icon = 'timer'
            })
        end
    end

    lastGameTimer = gameTimer
    gameTimer = newTimer
end

-- Hide phase handlers
onHidePhaseStart = function(data)
    -- data: "roundId,seconds" (new) or just seconds
    local roundStr, secStr = tostring(data or ""):match("^%s*(%d+)%s*,%s*(%d+)%s*$")
    if roundStr then currentRoundId = tonumber(roundStr) end
    local secs = tonumber(secStr) or tonumber(data) or 20

    hidePhase = true
    hideTimer = secs
    allowDisguise = false

    -- If we missed early AssignProp (late-loaded), request current state again.
    if playerTeam == "hider" and (not assignedPropName or assignedPropName == "") and TriggerServerEvent then
        TriggerServerEvent("PropHunt_requestState", "")
    end

    -- Freeze seeker's vehicle during hide phase
    if playerTeam == "seeker" then
        local playerVeh = be:getPlayerVehicle(0)
        if playerVeh then
            core_vehicleBridge.executeAction(playerVeh, 'setFreeze', true)
            print("DEBUG: Seeker vehicle frozen during hide phase")
        end

        guihooks.trigger('Message', {
            msg = "Wait " .. hideTimer .. " seconds while hiders hide...",
            ttl = 3,
            icon = 'block'
        })
    else
        guihooks.trigger('Message', {
            msg = "Hide phase! " .. hideTimer .. " seconds to hide!",
            ttl = 3,
            icon = 'visibility_off'
        })
    end

    print("DEBUG: Hide phase started - " .. hideTimer .. " seconds")
end

onHideTimerUpdate = function(data)
    local roundStr, secStr = tostring(data or ""):match("^%s*(%d+)%s*,%s*(%d+)%s*$")
    if roundStr then currentRoundId = tonumber(roundStr) end
    hideTimer = tonumber(secStr) or tonumber(data) or 0
    showRoundHud("HIDE: " .. tostring(hideTimer) .. "s")
end

onHidePhaseEnd = function(data)
    local roundStr = tostring(data or ""):match("^%s*(%d+)%s*$")
    if roundStr then currentRoundId = tonumber(roundStr) end

    hidePhase = false
    hideTimer = 0
    allowDisguise = true

    -- Unfreeze seeker's vehicle when hide phase ends
    if playerTeam == "seeker" then
        local playerVeh = be:getPlayerVehicle(0)
        if playerVeh then
            core_vehicleBridge.executeAction(playerVeh, 'setFreeze', false)
            print("DEBUG: Seeker vehicle unfrozen - hunt begins!")
        end

        guihooks.trigger('Message', {
            msg = "Hunt begins NOW!",
            ttl = 3,
            icon = 'visibility'
        })
    else
        -- Hiders: now transform into prop
        if assignedPropName and assignedPropName ~= "" then
            spawnAndAttachProp(assignedPropName)
        else
            print("WARN: Hide phase ended but no prop assigned yet; requesting state")
            if TriggerServerEvent then TriggerServerEvent("PropHunt_requestState", "") end
        end

        guihooks.trigger('Message', {
            msg = "Hide phase over! You're now a prop.",
            ttl = 3,
            icon = 'warning'
        })
    end
    print("DEBUG: Hide phase ended")
end

onRoundStart = function(data)
    local roundStr = tostring(data or ""):match("^%s*(%d+)%s*$")
    if roundStr then currentRoundId = tonumber(roundStr) end

    allowDisguise = true
    print("DEBUG: Main round started")

    -- Late-load / missed hide-phase end: if we already have an assigned prop, apply now.
    if playerTeam == "hider" and assignedPropName and assignedPropName ~= "" then
        spawnAndAttachProp(assignedPropName)
    end
end

onPlayerEliminated = function(data)
    -- data can be "<playerId>" or "<playerId>,<playerName>"
    local pidStr, nameStr = tostring(data or ""):match("^%s*(%d+)%s*,?%s*(.*)$")
    local targetId = tonumber(pidStr)
    if not targetId then return end

    local label = (nameStr and nameStr ~= "") and nameStr or ("Player " .. tostring(targetId))

    guihooks.trigger('Message', {
        msg = label .. " eliminated",
        ttl = 3,
        icon = 'close'
    })

    -- If it's us, revert back to our pre-disguise vehicle (best-effort)
    if MPVehicleGE and MPVehicleGE.getServerVehicleID then
        local myVehId = be:getPlayerVehicleID(0)
        local myServerVeh = myVehId and MPVehicleGE.getServerVehicleID(myVehId)
        if myServerVeh then
            local myPid = tonumber(string.match(tostring(myServerVeh), "(%d+)%-%d+"))
            if myPid and myPid == targetId then
                if preDisguiseModelKey and core_vehicles and core_vehicles.replaceVehicle then
                    local ok, err = pcall(function()
                        if preDisguiseConfig and type(preDisguiseConfig) == 'string' and preDisguiseConfig ~= '' then
                            core_vehicles.replaceVehicle(preDisguiseModelKey, { config = preDisguiseConfig })
                        else
                            core_vehicles.replaceVehicle(preDisguiseModelKey, {})
                        end
                    end)
                    if ok then
                        guihooks.trigger('Message', { msg = "You were found! Reverting to car.", ttl = 4, icon = 'directions_car' })
                    else
                        print("ERROR: Failed to revert to car: " .. tostring(err))
                    end
                else
                    print("WARN: No preDisguiseModelKey captured; cannot revert")
                end
            end
        end
    end
end

onRoundEnd = function(data)
    -- data can contain a reason string from the server
    local reason = tostring(data or "")

    -- Play end sound for all players
    local playerVeh = be:getPlayerVehicle(0)
    if playerVeh then
        local vehID = playerVeh:getID()
        local endSound = "art/Sounds/Taunts/end.ogg"
        playSound(endSound, vehID, 999999) -- Very large distance so everyone hears it
    end

    local msg = "END OF ROUND!"
    if reason ~= "" then
        msg = "END OF ROUND (" .. reason .. ")"
    end

    guihooks.trigger('Message', {
        msg = msg,
        ttl = 5,
        icon = 'flag'
    })
    print("DEBUG: Round ended: " .. reason)
end

-- --- CHAT COMMANDS ---
onChatMessage = function(msg)
    -- Parse message format: "sender:message"
    local colonIndex = string.find(msg, ":")
    if not colonIndex then return end

    local message = string.sub(msg, colonIndex + 1, -1)

    -- Check if message is a PropHunt command
    if not message:match("^/ph") then return end

    local args = {}
    for word in message:gmatch("%S+") do
        table.insert(args, word)
    end

    local cmd = args[1]

    if cmd == "/phconfig" or cmd == "/phset" then
        if #args < 3 then
            guihooks.trigger('Message', {
                msg = "Usage: /phconfig <setting> <value>\nSettings: taunt_dist, flash_dist, flash_cooldown, flash_effect_dist",
                ttl = 5,
                icon = 'info'
            })
            return
        end

        local setting = args[2]:lower()
        local value = tonumber(args[3])

        if not value then
            guihooks.trigger('Message', {
                msg = "Error: Value must be a number",
                ttl = 3,
                icon = 'error'
            })
            return
        end

        if setting == "taunt_dist" then
            TAUNT_SOUND_DISTANCE = value
            guihooks.trigger('Message', {
                msg = "Taunt sound distance set to " .. value .. " meters",
                ttl = 3,
                icon = 'check'
            })
        elseif setting == "flash_dist" then
            FLASH_SOUND_DISTANCE = value
            guihooks.trigger('Message', {
                msg = "Flashbang sound distance set to " .. value .. " meters",
                ttl = 3,
                icon = 'check'
            })
        elseif setting == "flash_cooldown" then
            FLASH_COOLDOWN = value
            guihooks.trigger('Message', {
                msg = "Flashbang cooldown set to " .. value .. " seconds",
                ttl = 3,
                icon = 'check'
            })
        elseif setting == "flash_effect_dist" then
            -- Update flash effect distance in PropHuntFlash extension
            if extensions.PropHuntFlash and extensions.PropHuntFlash.setFlashRange then
                extensions.PropHuntFlash.setFlashRange(value)
                guihooks.trigger('Message', {
                    msg = "Flashbang effect distance set to " .. value .. " meters",
                    ttl = 3,
                    icon = 'check'
                })
            else
                guihooks.trigger('Message', {
                    msg = "Error: PropHuntFlash extension not loaded",
                    ttl = 3,
                    icon = 'error'
                })
            end
        else
            guihooks.trigger('Message', {
                msg = "Unknown setting: " .. setting .. "\nAvailable: taunt_dist, flash_dist, flash_cooldown, flash_effect_dist",
                ttl = 5,
                icon = 'error'
            })
        end
    elseif cmd == "/phtag" then
        -- /phtag <playerId>
        if #args < 2 then
            guihooks.trigger('Message', {
                msg = "Usage: /phtag <playerId> (seekers only)",
                ttl = 5,
                icon = 'info'
            })
            return
        end

        local targetId = tonumber(args[2])
        if not targetId then
            guihooks.trigger('Message', {
                msg = "Error: playerId must be a number",
                ttl = 3,
                icon = 'error'
            })
            return
        end

        if TriggerServerEvent then
            TriggerServerEvent("PropHunt_TagRequest", tostring(targetId))
            guihooks.trigger('Message', {
                msg = "Tag request sent for player " .. tostring(targetId),
                ttl = 2,
                icon = 'near_me'
            })
        else
            guihooks.trigger('Message', {
                msg = "Error: TriggerServerEvent not available",
                ttl = 3,
                icon = 'error'
            })
        end

  elseif cmd == "/phhelp" then
        guihooks.trigger('Message', {
            msg = "PropHunt Commands:\n" ..
                  "/phconfig <setting> <value> - Configure client distances\n" ..
                  "Settings: taunt_dist, flash_dist, flash_cooldown, flash_effect_dist\n" ..
                  "/phtag <playerId> - (seekers) tag a hider (temporary until automatic tagging)",
            ttl = 9,
            icon = 'help'
        })
    end
end

-- --- EXPORTS ---
M.onExtensionLoaded = onExtensionLoaded
M.onUpdate = onUpdate
M.onChatMessage = onChatMessage
M.setRunner = setRunner
M.setProp = setProp
M.performSwap = performSwap
M.manualTaunt = manualTaunt
M.playSound = playSound
M.getPropID = function() return propID end


-- =============================
-- COLLISION TAGGING (Seeker)
-- =============================
local function resolveOwnerPlayerIdFromVehId(vehId)
    -- Best method (used in Outbreak): convert gameVehicleID -> serverVehicleID -> playerId
    -- serverVehicleID format: "<playerId>-<vehicleIndex>" (e.g. "1-0")
    if not vehId then return nil end

    if MPVehicleGE and MPVehicleGE.getServerVehicleID then
        local ok, serverVeh = pcall(function() return MPVehicleGE.getServerVehicleID(vehId) end)
        if ok and serverVeh then
            local pid = string.match(tostring(serverVeh), "(%d+)%-%d+")
            if pid then return tonumber(pid) end
        end
    end

    -- fallback attempts (older/alt APIs)
    local candidates = {
        function()
            if MPVehicleGE and MPVehicleGE.getOwnerID then return MPVehicleGE.getOwnerID(vehId) end
        end,
        function()
            if MPVehicleGE and MPVehicleGE.getVehicleOwner then return MPVehicleGE.getVehicleOwner(vehId) end
        end,
        function()
            if MPVehicleGE and MPVehicleGE.getOwner then return MPVehicleGE.getOwner(vehId) end
        end,
        function()
            if MPGameNetwork and MPGameNetwork.getVehicleOwner then return MPGameNetwork.getVehicleOwner(vehId) end
        end,
    }

    for _, fn in ipairs(candidates) do
        local ok, res = pcall(fn)
        if ok and res ~= nil then
            local n = tonumber(res)
            if n then return n end
        end
    end

    return nil
end

local lastAutoTagTime = 0
local AUTO_TAG_COOLDOWN = 0.5

local function onSeekerCollision(otherVehId)
    if not gameActive or hidePhase then return end
    if playerTeam ~= "seeker" then return end

    local t = os.clock()
    if (t - lastAutoTagTime) < AUTO_TAG_COOLDOWN then return end
    lastAutoTagTime = t

    local otherId = tonumber(otherVehId)
    if not otherId then return end

    local targetPlayerId = resolveOwnerPlayerIdFromVehId(otherId)
    if not targetPlayerId then
        -- No mapping available; keep quiet to avoid spam.
        -- Users can still use /phtag.
        print("DEBUG: Could not resolve owner for collided vehicle " .. tostring(otherId) .. " (BeamMP API mismatch)")
        return
    end

    if TriggerServerEvent then
        TriggerServerEvent("PropHunt_TagRequest", tostring(targetPlayerId))
        print("DEBUG: Auto-tag collision => requested tag on player " .. tostring(targetPlayerId))
    end
end

-- =============================
-- HIDER DISGUISE (BeamNG props)
-- =============================
local assignedPropName = nil
local attachedPropObjId = nil

-- store what we were driving before disguising, so we can revert on elimination
local preDisguiseModelKey = nil
local preDisguiseConfig = nil -- best-effort

local function deleteAttachedProp()
    if attachedPropObjId then
        local obj = scenetree.findObjectById(attachedPropObjId)
        if obj then obj:delete() end
    end
    attachedPropObjId = nil
end

local function tryHideVehicle(veh, hide)
    -- Best-effort: BeamNG API varies. We'll try a few possibilities.
    if not veh then return end

    -- Some versions expose mesh alpha via vehicleBridge action
    if core_vehicleBridge and core_vehicleBridge.executeAction then
        pcall(function()
            -- Not guaranteed to exist; if it does, 0=hidden, 1=visible
            core_vehicleBridge.executeAction(veh, 'setMeshAlpha', hide and 0 or 1)
        end)
    end

    -- Fallback: dim lights / reduce visibility a bit
    pcall(function()
        if hide then
            veh:queueLuaCommand("electrics.values.lights = 0")
        end
    end)
end

local function spawnAndAttachProp(propName)
    -- BeamNG "props" in this context are Prop vehicles (Type == 'Prop')
    -- so we disguise by replacing the player's vehicle with a prop vehicle.
    --
    -- IMPORTANT: hardcoded prop keys can differ across versions/modpacks.
    -- So we support:
    --  - server sending an explicit prop key
    --  - OR propName == "random" to pick from core_vehicles.getModelList(true)
    --  - OR fallback to random if the explicit key fails.

    deleteAttachedProp() -- legacy object-based disguise; no longer used

    if not core_vehicles or not core_vehicles.replaceVehicle or not core_vehicles.getModelList then
        guihooks.trigger('Message', { msg = "Prop disguise failed: core_vehicles API not available", ttl = 4, icon = 'error' })
        print("ERROR: core_vehicles API not available")
        return
    end

    -- Exclusions (from your example / known problematic huge props)
    local excluded = {
        flipramp = true,
        kickplate = true,
        large_angletester = true,
        large_bridge = true,
        large_cannon = true,
        large_crusher = true,
        large_hamster_wheel = true,
        large_roller = true,
        large_spinner = true,
        metal_ramp = true,
        weightpad = true,
        suspensionbridge = true,
        rollover = true,
    }

    local function isExcluded(key)
        return excluded[tostring(key)] == true
    end

    local function pickRandomPropModelKey()
        local ok, ml = pcall(function() return core_vehicles.getModelList(true) end)
        if not ok or not ml or not ml.models then return nil end
        local models = ml.models
        if #models == 0 then return nil end

        local attempts = 0
        local chosen
        repeat
            attempts = attempts + 1
            chosen = models[math.random(1, #models)]
        until (chosen and chosen.Type == 'Prop' and not isExcluded(chosen.key)) or attempts > 500

        if chosen and chosen.Type == 'Prop' and not isExcluded(chosen.key) then
            return chosen.key, chosen.Name
        end
        return nil
    end

    local function pickRandomPropConfig(modelKey)
        if not core_vehicles or not core_vehicles.getConfigList then return nil end
        local ok, list = pcall(function() return core_vehicles.getConfigList(true) end)
        if not ok or not list or not list.configs then return nil end

        local configs = {}
        for _, v in pairs(list.configs) do
            if v.model_key == modelKey then
                table.insert(configs, v)
            end
        end
        if #configs == 0 then return nil end

        local c = configs[math.random(#configs)]
        return c and c.key or nil
    end

    local modelKey = propName
    local modelLabel = propName

    if tostring(propName) == "random" or tostring(propName) == "" or tostring(propName) == "nil" then
        local k, name = pickRandomPropModelKey()
        if not k then
            guihooks.trigger('Message', { msg = "Prop disguise failed: no prop models found", ttl = 4, icon = 'error' })
            return
        end
        modelKey = k
        modelLabel = name or k
    end

    local function doReplace(key)
        -- Capture current vehicle before replacing (best-effort)
        do
            local curVehId = be:getPlayerVehicleID(0)
            if curVehId and MPVehicleGE and MPVehicleGE.getVehicleByGameID then
                local v = MPVehicleGE.getVehicleByGameID(curVehId)
                if v and v.jbeam then
                    preDisguiseModelKey = v.jbeam
                end
                if v and v.partConfigFilename then
                    preDisguiseConfig = v.partConfigFilename
                end
            end
        end

        local cfgKey = pickRandomPropConfig(key)
        if cfgKey then
            core_vehicles.replaceVehicle(key, { config = cfgKey })
        else
            core_vehicles.replaceVehicle(key, {})
        end
    end

    -- Prevent repeated transform spam
    if disguisedThisRound then
        print("DEBUG: Disguise already applied this round, skipping")
        return
    end

    local ok, err = pcall(function() doReplace(modelKey) end)

    if not ok then
        -- fallback: server key maybe doesn't exist in this build; pick random prop
        print("WARN: replaceVehicle failed for '" .. tostring(modelKey) .. "' => " .. tostring(err) .. "; falling back to random prop")
        local k, name = pickRandomPropModelKey()
        if not k then
            guihooks.trigger('Message', { msg = "Prop disguise failed: " .. tostring(modelKey), ttl = 4, icon = 'error' })
            return
        end
        modelKey = k
        modelLabel = name or k
        ok, err = pcall(function() doReplace(modelKey) end)
    end

    if ok then
        disguisedThisRound = true
        guihooks.trigger('Message', { msg = "Disguised as prop: " .. tostring(modelLabel), ttl = 4, icon = 'local_shipping' })
        print("DEBUG: Replaced vehicle with prop: " .. tostring(modelKey))
    else
        guihooks.trigger('Message', { msg = "Prop disguise failed: " .. tostring(modelKey), ttl = 4, icon = 'error' })
        print("ERROR: Failed to replace vehicle with prop '" .. tostring(modelKey) .. "': " .. tostring(err))
    end
end

local function updateAttachedPropTransform()
    -- legacy: object-attached props; no longer used
end

onAssignProp = function(data)
    -- data: "roundId,propKey" (new) or just propKey
    local roundStr, propKey = tostring(data or ""):match("^%s*(%d+)%s*,%s*([^,]+)%s*$")
    if propKey then
        assignedPropName = tostring(propKey)
        currentRoundId = tonumber(roundStr) or currentRoundId
    else
        assignedPropName = tostring(data or "")
    end

    if assignedPropName == "" then return end

    guihooks.trigger('Message', { msg = "Prop assigned: " .. assignedPropName, ttl = 4, icon = 'local_shipping' })

    -- Apply at most once per round
    if currentRoundId and disguisedRoundId == currentRoundId then
        return
    end

    if allowDisguise and playerTeam == "hider" then
        spawnAndAttachProp(assignedPropName)
        disguisedRoundId = currentRoundId
    else
        print("DEBUG: Prop assigned; will disguise at hide-phase end (allowDisguise=" .. tostring(allowDisguise) .. ", team=" .. tostring(playerTeam) .. ")")
    end
end

-- Export a callable so we can trigger from UI/keybind later if desired
M.onSeekerCollision = onSeekerCollision


-- =============================
-- SEEKER TAGGING (Outbreak-style collision contact)
-- =============================
local lastTagContact = 0
local TAG_CONTACT_COOLDOWN = 0.25

local function sendTagContact(remoteVehID, localVehID)
    if not gameActive or hidePhase then return end
    if playerTeam ~= "seeker" then return end

    local t = os.clock()
    if (t - lastTagContact) < TAG_CONTACT_COOLDOWN then return end
    lastTagContact = t

    -- Only act if the local vehicle is ours
    if MPVehicleGE and MPVehicleGE.isOwn and not MPVehicleGE.isOwn(localVehID) then
        return
    end

    -- Map remote vehicle -> remote playerId using server vehicle string "pid-vid"
    if MPVehicleGE and MPVehicleGE.getServerVehicleID then
        local serverVehID = MPVehicleGE.getServerVehicleID(remoteVehID)
        if serverVehID then
            local remotePid = tonumber(string.match(tostring(serverVehID), "(%d+)%-%d+"))
            if remotePid and TriggerServerEvent then
                TriggerServerEvent("PropHunt_TagRequest", tostring(remotePid))
                return
            end
        end
    end
end

M.sendTagContact = sendTagContact

M.manualFlashSound = manualFlashSound
return M