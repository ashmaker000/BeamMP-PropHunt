-- lua/ge/extensions/PropHunt.lua
local M = {}

-- --- CONFIG ---
local TAUNT_INTERVAL = 30
local TAUNT_SOUND_DISTANCE = 50 -- how far taunts can be heard (reduced from 150)
local FLASH_SOUND_DISTANCE = 300 -- how far flashbangs can be heard
local FLASH_COOLDOWN = 15 -- cooldown in seconds between flashbang uses

local SOUND_VOLUME = 1
local MAX_SOUND_LENGTH = 10

-- --- STATE ---
local runnerID = nil
local propID = nil
local isHidden = false
local tauntTimer = 0
local uiTimer = 0
local activeEmitters = {}
local flashCooldownTimer = 0 -- tracks time since last flashbang

-- --- GAME STATE ---
local playerTeam = nil -- "seeker" or "hider"
local gameActive = false
local gameTimer = 0
local lastGameTimer = 0 -- track previous timer value for notifications
local hidePhase = false -- True during 20-second hide countdown
local hideTimer = 0

-- Forward declarations for network handlers
local onNetworkTaunt
local onNetworkFlashSound
local onGameStart
local onGameEnd
local onTimerUpdate
local onHidePhaseStart
local onHideTimerUpdate
local onHidePhaseEnd
local onRoundStart
local onRoundEnd
local onPlayerEliminated
local onAssignProp

local function onExtensionLoaded()
    print("DEBUG: PropHunt Core LOADED.")

    -- Ensure PropHuntFlash extension is loaded
    if not extensions.PropHuntFlash then
        local ok, err = pcall(function() extensions.load("PropHuntFlash") end)
        if ok then
            print("DEBUG: PropHuntFlash extension loaded successfully")
        else
            print("ERROR: Failed to load PropHuntFlash: " .. tostring(err))
        end
    end

    -- Register network event handlers
    if MPGameNetwork then
        AddEventHandler("PropHunt_Taunt", onNetworkTaunt)
        print("DEBUG: Registered handler for PropHunt_Taunt")
        AddEventHandler("PropHunt_Flashbang", onNetworkFlashSound)
        print("DEBUG: Registered handler for PropHunt_Flashbang")

        -- Register game state handlers
        AddEventHandler("PropHunt_GameStart", onGameStart)
        print("DEBUG: Registered handler for PropHunt_GameStart")
        AddEventHandler("PropHunt_GameEnd", onGameEnd)
        print("DEBUG: Registered handler for PropHunt_GameEnd")
        AddEventHandler("PropHunt_TimerUpdate", onTimerUpdate)
        print("DEBUG: Registered handler for PropHunt_TimerUpdate")
        AddEventHandler("PropHunt_HidePhaseStart", onHidePhaseStart)
        print("DEBUG: Registered handler for PropHunt_HidePhaseStart")
        AddEventHandler("PropHunt_HideTimerUpdate", onHideTimerUpdate)
        print("DEBUG: Registered handler for PropHunt_HideTimerUpdate")
        AddEventHandler("PropHunt_HidePhaseEnd", onHidePhaseEnd)
        print("DEBUG: Registered handler for PropHunt_HidePhaseEnd")
        AddEventHandler("PropHunt_RoundStart", onRoundStart)
        print("DEBUG: Registered handler for PropHunt_RoundStart")
        AddEventHandler("PropHunt_RoundEnd", onRoundEnd)
        print("DEBUG: Registered handler for PropHunt_RoundEnd")

        AddEventHandler("PropHunt_PlayerEliminated", onPlayerEliminated)
        print("DEBUG: Registered handler for PropHunt_PlayerEliminated")

        AddEventHandler("PropHunt_AssignProp", onAssignProp)
        print("DEBUG: Registered handler for PropHunt_AssignProp")

        -- Register chat command handler
        AddEventHandler("ChatMessageReceived", onChatMessage)
        print("DEBUG: Registered PropHunt chat command handler")
    else
        print("ERROR: MPGameNetwork not available - network handlers NOT registered!")
    end
end

-- --- AUDIO SYSTEM ---
local function playSound(filename, vehID, maxDistance)
    -- Remove old emitter if exists
    if activeEmitters[vehID] then
        local oldEmitter = scenetree.findObjectById(activeEmitters[vehID].id)
        if oldEmitter then oldEmitter:delete() end
        activeEmitters[vehID] = nil
    end

    local veh = be:getObjectByID(vehID)
    local pos

    if not veh then
        -- If source vehicle doesn't exist (MP sync issue), play at player position
        print("DEBUG: Source vehicle " .. vehID .. " not found, playing sound at player position")
        local playerVeh = be:getPlayerVehicle(0)
        if not playerVeh then return end
        pos = playerVeh:getPosition()
    else
        pos = veh:getPosition()
    end

    -- Use provided distance or default to taunt distance
    local soundDistance = maxDistance or TAUNT_SOUND_DISTANCE

    local newObj = createObject('SFXEmitter')
    newObj:setPosition(pos)
    newObj:setField('filename', 0, filename)
    newObj:setField('playOnAdd', 0, "1")
    newObj:setField('isLooping', 0, "0")
    newObj:setField('maxDistance', 0, tostring(soundDistance))
    newObj:setField('volume', 0, tostring(SOUND_VOLUME))
    newObj.canSave = false
    newObj:registerObject("PropHunt_SFX_"..vehID)

    local grp = scenetree.MissionGroup
    if grp then grp:addObject(newObj) end
    activeEmitters[vehID] = { id = newObj:getID(), timer = MAX_SOUND_LENGTH }
end


-- --- RUNNER SET FUNCTION ---
local function setRunner()
    local veh = be:getPlayerVehicle(0)
    if not veh then return end

    runnerID = veh:getID()
    isHidden = false
    tauntTimer = 0

    guihooks.trigger('Message', {
        msg = "PropHunt: Runner Set!",
        ttl = 2,
        icon = 'directions_car'
    })
end

-- --- PROP SET FUNCTION ---
local function setProp()
    local veh = be:getPlayerVehicle(0)
    if not veh then return end

    propID = veh:getID()

    guihooks.trigger('Message',{
        msg = "PropHunt: Prop Set!",
        ttl = 2,
        icon = 'local_shipping'
    })
end

-- --- SWAP VEHICLES ---
local function performSwap()
    if not runnerID or not propID then
        guihooks.trigger('Message',{
            msg = "Error: Set both vehicles first!",
            ttl = 3,
            icon = 'error'
        })
        return
    end

    local vRunner = be:getObjectByID(runnerID)
    local vProp = be:getObjectByID(propID)

    -- If either vehicle is missing, return silently like the old version
    if not vRunner or not vProp then
        print("DEBUG: One or both vehicles not found (IDs may have changed after reset)")
        guihooks.trigger('Message',{
            msg = "Error: One or both vehicles not found. Please re-set them.",
            ttl = 3,
            icon = 'error'
        })
        return
    end

    -- swap positions
    local posRunner = vRunner:getPosition()
    local rotRunner = vRunner:getRotation()
    local posProp = vProp:getPosition()
    local rotProp = vProp:getRotation()

    vRunner:setPositionRotation(posProp.x,posProp.y,posProp.z,rotProp.x,rotProp.y,rotProp.z,rotProp.w)
    vProp:setPositionRotation(posRunner.x,posRunner.y,posRunner.z,rotRunner.x,rotRunner.y,rotRunner.z,rotRunner.w)

    vRunner:queueLuaCommand("obj:requestReset(RESET_PHYSICS)")
    vProp:queueLuaCommand("obj:requestReset(RESET_PHYSICS)")

    isHidden = not isHidden
    tauntTimer = TAUNT_INTERVAL

    if isHidden then
        be:enterVehicle(0, vProp)
    else
        be:enterVehicle(0, vRunner)
    end

    -- IMPORTANT: Update stored IDs after entering the vehicle
    -- The physics reset and vehicle enter may have changed the vehicle IDs
    -- We need to get the fresh IDs after all operations complete
    local finalVeh = be:getPlayerVehicle(0)
    if finalVeh then
        local finalID = finalVeh:getID()
        if isHidden then
            -- We're now in the prop, update prop ID
            propID = finalID
            print("DEBUG: Updated propID to " .. finalID .. " after swap")
        else
            -- We're now in the runner, update runner ID
            runnerID = finalID
            print("DEBUG: Updated runnerID to " .. finalID .. " after swap")
        end
    end
end

-- --- TAUNT ---
local function triggerTaunt()
    if not propID then return end
    local veh = be:getObjectByID(propID)
    if not veh then return end

    -- LOCAL SOUND
    local selectedSound = "art/Sounds/Taunts/clown.ogg"
    veh:queueLuaCommand("electrics.values.phTaunt = '" .. selectedSound .. "'")

    -- NETWORK SOUND
    if MPCoreNetwork and MPCoreNetwork.isMPSession() and TriggerServerEvent then
        TriggerServerEvent("PropHunt_TauntRequest", tostring(propID))
    end
end

local function manualTaunt()
    triggerTaunt()
    tauntTimer = TAUNT_INTERVAL
end



-- --- FLASHBANG SOUND (mirrors taunt pipeline, but uses flash.ogg) ---
local function manualFlashSound(optionalVehID)
    -- Check cooldown
    if flashCooldownTimer > 0 then
        guihooks.trigger('Message', {
            msg = string.format("Flashbang on cooldown: %.1fs remaining", flashCooldownTimer),
            ttl = 2,
            icon = 'timer'
        })
        print("DEBUG: Flashbang on cooldown: " .. string.format("%.1f", flashCooldownTimer) .. "s remaining")
        return
    end

    -- Use passed vehID if given, otherwise use the player's current vehicle
    local veh = nil
    local vehID = optionalVehID

    if vehID and type(vehID) == 'number' then
        veh = be:getObjectByID(vehID)
    end

    if not veh then
        veh = be:getPlayerVehicle(0)
        if not veh then return end
        vehID = veh:getID()
    end

    -- Reset cooldown timer
    flashCooldownTimer = FLASH_COOLDOWN

    -- Local: play flashbang sound at this vehicle (with 300 unit range)
    local selectedSound = "art/Sounds/Taunts/flash.ogg"
    playSound(selectedSound, vehID, FLASH_SOUND_DISTANCE)

    -- Multiplayer: notify server so other clients can hear it
    if MPCoreNetwork and MPCoreNetwork.isMPSession() then
        print("DEBUG: In multiplayer session, sending flashbang request for vehicle " .. vehID)
        if TriggerServerEvent then
            -- Just send vehicle ID - position will be sent via separate mechanism
            TriggerServerEvent("PropHunt_FlashbangRequest", tostring(vehID))
            print("DEBUG: PropHunt_FlashbangRequest sent to server")
        else
            print("ERROR: TriggerServerEvent function not available!")
        end
    else
        print("DEBUG: Not in multiplayer session (MPCoreNetwork check failed)")
    end
end

-- --- UPDATE LOOP ---
local function onUpdate(dt)
    -- FLASHBANG COOLDOWN
    if flashCooldownTimer > 0 then
        flashCooldownTimer = flashCooldownTimer - dt
        if flashCooldownTimer < 0 then
            flashCooldownTimer = 0
        end
    end

    -- VEHICLE ID VALIDATION - Check if stored vehicle IDs are still valid after resets
    -- This handles the case where a vehicle is fully reset (destroyed and recreated with new ID)
    if runnerID or propID then
        local playerVeh = be:getPlayerVehicle(0)

        if playerVeh then
            local currentID = playerVeh:getID()

            -- Check if stored runner vehicle still exists
            if runnerID then
                local vRunner = be:getObjectByID(runnerID)
                if not vRunner then
                    -- Runner vehicle object no longer exists (was reset)
                    -- If we're currently in a vehicle that's not the prop ID, update runner
                    if currentID ~= propID then
                        print("DEBUG: Runner vehicle ID changed from " .. runnerID .. " to " .. currentID)
                        runnerID = currentID
                        guihooks.trigger('Message', {
                            msg = "Runner vehicle auto-recovered",
                            ttl = 2,
                            icon = 'info'
                        })
                    end
                end
            end

            -- Check if stored prop vehicle still exists
            if propID then
                local vProp = be:getObjectByID(propID)
                if not vProp then
                    -- Prop vehicle object no longer exists (was reset)
                    -- If we're currently in a vehicle that's not the runner ID, update prop
                    if currentID ~= runnerID then
                        print("DEBUG: Prop vehicle ID changed from " .. propID .. " to " .. currentID)
                        propID = currentID
                        guihooks.trigger('Message', {
                            msg = "Prop vehicle auto-recovered",
                            ttl = 2,
                            icon = 'info'
                        })
                    end
                end
            end
        end
    end

    -- AUTO TAUNT
    if isHidden and propID then
        tauntTimer = tauntTimer - dt
        if tauntTimer <= 0 then
            triggerTaunt()
            tauntTimer = TAUNT_INTERVAL
        end

        -- Reset electrics a moment later so sound doesn't loop incorrectly
        if tauntTimer < (TAUNT_INTERVAL - 2) and tauntTimer > (TAUNT_INTERVAL - 2.2) then
            local veh = be:getObjectByID(propID)
            if veh then
                veh:queueLuaCommand("electrics.values.phTaunt = ''")
            end
        end
    end

    -- UPDATE ACTIVE SOUND EMITTERS
    for vid, data in pairs(activeEmitters) do
        local emitter = scenetree.findObjectById(data.id)
        if emitter then
            data.timer = data.timer - dt
            if data.timer <= 0 then
                emitter:delete()
                activeEmitters[vid] = nil
            else
                local veh = be:getObjectByID(vid)
                if veh then emitter:setPosition(veh:getPosition()) end
            end
        else
            activeEmitters[vid] = nil
        end
    end

    -- E) (legacy) attached prop syncing no longer used; disguise is via replaceVehicle(prop)

    -- UPDATE UI
    uiTimer = uiTimer + dt
    if uiTimer > 0.1 then
        uiTimer = 0
        guihooks.trigger('PropHuntUpdate',{
            isHidden = isHidden,
            timer = tauntTimer,
            runnerSet = (runnerID ~= nil),
            propSet = (propID ~= nil),
            gameActive = gameActive,
            gameTimer = gameTimer,
            playerTeam = playerTeam,
            hidePhase = hidePhase,
            hideTimer = hideTimer
        })
    end
end



-- --- NETWORK HANDLERS (Taunt + Flash sound) ---
onNetworkTaunt = function(data)
    local vehID = tonumber(data)
    if not vehID then return end

    -- Don't double-taunt the owner
    local playerVeh = be:getPlayerVehicle(0)
    if playerVeh and playerVeh:getID() == vehID then return end

    -- Play taunt for remote players
    local selectedSound = "art/Sounds/Taunts/clown.ogg"
    playSound(selectedSound, vehID)
end

onNetworkFlashSound = function(data)
    -- Parse data: "sourcePlayerID,vehID"
    local parts = {}
    for part in string.gmatch(data, "[^,]+") do
        table.insert(parts, part)
    end

    local sourcePlayerID = tonumber(parts[1])
    local vehID = tonumber(parts[2])

    if not sourcePlayerID or not vehID then
        print("ERROR: Invalid flashbang data format: " .. tostring(data))
        return
    end

    print("DEBUG: PropHunt.onNetworkFlashSound received - sourcePlayer: " .. tostring(sourcePlayerID) .. ", veh: " .. vehID)

    -- Don't double-play on the source client; they already played it locally
    local playerVeh = be:getPlayerVehicle(0)
    if playerVeh and playerVeh:getID() == vehID then
        print("DEBUG: Skipping own flashbang (already played locally)")
        return
    end

    -- Play flashbang sound for remote players (with 300 unit range)
    local selectedSound = "art/Sounds/Taunts/flash.ogg"
    playSound(selectedSound, vehID, FLASH_SOUND_DISTANCE)

    -- ALSO trigger visual flash effect for remote players
    if extensions.PropHuntFlash and extensions.PropHuntFlash.handleFlashbang then
        print("DEBUG: Calling PropHuntFlash.handleFlashbang with sourcePlayerID: " .. sourcePlayerID)
        extensions.PropHuntFlash.handleFlashbang(vehID, sourcePlayerID)
    else
        print("ERROR: PropHuntFlash extension not found or handleFlashbang missing!")
    end
end

-- NOTE: Network handlers are now registered in onExtensionLoaded() above

-- --- GAME STATE HANDLERS ---
onGameStart = function(data)
    local team = data
    playerTeam = team
    gameActive = true
    gameTimer = 300
    lastGameTimer = 300 -- reset timer tracking

    if team == "seeker" then
        guihooks.trigger('Message', {
            msg = "You are a SEEKER! Find and tag the hiders!",
            ttl = 5,
            icon = 'visibility'
        })
        print("DEBUG: You are a SEEKER")
    else
        guihooks.trigger('Message', {
            msg = "You are a HIDER! Hide and survive for 5 minutes!",
            ttl = 5,
            icon = 'visibility_off'
        })
        print("DEBUG: You are a HIDER")

        -- E) Apply disguise if the server already assigned a prop before GameStart arrived.
        if assignedPropName and assignedPropName ~= "" then
            spawnAndAttachProp(assignedPropName)
        end
    end
end

onGameEnd = function(data)
    -- data may contain a reason/winner string from server (timeout/seekers/manual/etc)
    local reason = tostring(data or "")

    playerTeam = nil
    gameActive = false
    gameTimer = 0
    lastGameTimer = 0 -- reset timer tracking
    hidePhase = false
    hideTimer = 0

    local msg = "Game Over!"
    if reason ~= "" then
        if reason == "timeout" or reason == "hiders" then
            msg = "Round Over: Hiders win!"
        elseif reason == "seekers" then
            msg = "Round Over: Seekers win!"
        elseif reason == "manual" then
            msg = "Round Over: Stopped"
        else
            msg = "Round Over: " .. reason
        end
    end

    guihooks.trigger('Message', {
        msg = msg,
        ttl = 4,
        icon = 'flag'
    })
    print("DEBUG: Game ended (" .. reason .. ")")
end

onTimerUpdate = function(data)
    local newTimer = tonumber(data) or 0

    -- Check for timer milestones and show notifications (only during main round, not hide phase)
    if gameActive and not hidePhase then
        -- Minute updates
        if lastGameTimer > 60 and newTimer <= 60 then
            guihooks.trigger('Message', {
                msg = "1 minute remaining!",
                ttl = 3,
                icon = 'timer'
            })
        end

        -- 30 seconds remaining
        if lastGameTimer > 30 and newTimer <= 30 then
            guihooks.trigger('Message', {
                msg = "30 seconds remaining!",
                ttl = 3,
                icon = 'warning'
            })
        end

        -- Final countdown (10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
        if newTimer >= 1 and newTimer <= 10 and lastGameTimer > newTimer then
            guihooks.trigger('Message', {
                msg = tostring(newTimer),
                ttl = 1,
                icon = 'timer'
            })
        end
    end

    lastGameTimer = gameTimer
    gameTimer = newTimer
end

-- Hide phase handlers
onHidePhaseStart = function(data)
    hidePhase = true
    hideTimer = tonumber(data) or 20

    -- Freeze seeker's vehicle during hide phase
    if playerTeam == "seeker" then
        local playerVeh = be:getPlayerVehicle(0)
        if playerVeh then
            core_vehicleBridge.executeAction(playerVeh, 'setFreeze', true)
            print("DEBUG: Seeker vehicle frozen during hide phase")
        end

        guihooks.trigger('Message', {
            msg = "Wait " .. hideTimer .. " seconds while hiders hide...",
            ttl = 3,
            icon = 'block'
        })
    else
        guihooks.trigger('Message', {
            msg = "Hide phase! " .. hideTimer .. " seconds to hide!",
            ttl = 3,
            icon = 'visibility_off'
        })
    end

    print("DEBUG: Hide phase started - " .. hideTimer .. " seconds")
end

onHideTimerUpdate = function(data)
    hideTimer = tonumber(data) or 0
end

onHidePhaseEnd = function(data)
    hidePhase = false
    hideTimer = 0

    -- Unfreeze seeker's vehicle when hide phase ends
    if playerTeam == "seeker" then
        local playerVeh = be:getPlayerVehicle(0)
        if playerVeh then
            core_vehicleBridge.executeAction(playerVeh, 'setFreeze', false)
            print("DEBUG: Seeker vehicle unfrozen - hunt begins!")
        end

        guihooks.trigger('Message', {
            msg = "Hunt begins NOW!",
            ttl = 3,
            icon = 'visibility'
        })
    else
        guihooks.trigger('Message', {
            msg = "Hide phase over! Stay hidden!",
            ttl = 3,
            icon = 'warning'
        })
    end
    print("DEBUG: Hide phase ended")
end

onRoundStart = function(data)
    print("DEBUG: Main round started")
end

onPlayerEliminated = function(data)
    local targetId = tonumber(data)
    if not targetId then return end

    -- Just a lightweight notification for now. (Later: UI team list.)
    guihooks.trigger('Message', {
        msg = "Player " .. tostring(targetId) .. " eliminated",
        ttl = 3,
        icon = 'close'
    })
end

onRoundEnd = function(data)
    -- data can contain a reason string from the server
    local reason = tostring(data or "")

    -- Play end sound for all players
    local playerVeh = be:getPlayerVehicle(0)
    if playerVeh then
        local vehID = playerVeh:getID()
        local endSound = "art/Sounds/Taunts/end.ogg"
        playSound(endSound, vehID, 999999) -- Very large distance so everyone hears it
    end

    local msg = "END OF ROUND!"
    if reason ~= "" then
        msg = "END OF ROUND (" .. reason .. ")"
    end

    guihooks.trigger('Message', {
        msg = msg,
        ttl = 5,
        icon = 'flag'
    })
    print("DEBUG: Round ended: " .. reason)
end

-- --- CHAT COMMANDS ---
local function onChatMessage(msg)
    -- Parse message format: "sender:message"
    local colonIndex = string.find(msg, ":")
    if not colonIndex then return end

    local message = string.sub(msg, colonIndex + 1, -1)

    -- Check if message is a PropHunt command
    if not message:match("^/ph") then return end

    local args = {}
    for word in message:gmatch("%S+") do
        table.insert(args, word)
    end

    local cmd = args[1]

    if cmd == "/phconfig" or cmd == "/phset" then
        if #args < 3 then
            guihooks.trigger('Message', {
                msg = "Usage: /phconfig <setting> <value>\nSettings: taunt_dist, flash_dist, flash_cooldown, flash_effect_dist",
                ttl = 5,
                icon = 'info'
            })
            return
        end

        local setting = args[2]:lower()
        local value = tonumber(args[3])

        if not value then
            guihooks.trigger('Message', {
                msg = "Error: Value must be a number",
                ttl = 3,
                icon = 'error'
            })
            return
        end

        if setting == "taunt_dist" then
            TAUNT_SOUND_DISTANCE = value
            guihooks.trigger('Message', {
                msg = "Taunt sound distance set to " .. value .. " meters",
                ttl = 3,
                icon = 'check'
            })
        elseif setting == "flash_dist" then
            FLASH_SOUND_DISTANCE = value
            guihooks.trigger('Message', {
                msg = "Flashbang sound distance set to " .. value .. " meters",
                ttl = 3,
                icon = 'check'
            })
        elseif setting == "flash_cooldown" then
            FLASH_COOLDOWN = value
            guihooks.trigger('Message', {
                msg = "Flashbang cooldown set to " .. value .. " seconds",
                ttl = 3,
                icon = 'check'
            })
        elseif setting == "flash_effect_dist" then
            -- Update flash effect distance in PropHuntFlash extension
            if extensions.PropHuntFlash and extensions.PropHuntFlash.setFlashRange then
                extensions.PropHuntFlash.setFlashRange(value)
                guihooks.trigger('Message', {
                    msg = "Flashbang effect distance set to " .. value .. " meters",
                    ttl = 3,
                    icon = 'check'
                })
            else
                guihooks.trigger('Message', {
                    msg = "Error: PropHuntFlash extension not loaded",
                    ttl = 3,
                    icon = 'error'
                })
            end
        else
            guihooks.trigger('Message', {
                msg = "Unknown setting: " .. setting .. "\nAvailable: taunt_dist, flash_dist, flash_cooldown, flash_effect_dist",
                ttl = 5,
                icon = 'error'
            })
        end
    elseif cmd == "/phtag" then
        -- /phtag <playerId>
        if #args < 2 then
            guihooks.trigger('Message', {
                msg = "Usage: /phtag <playerId> (seekers only)",
                ttl = 5,
                icon = 'info'
            })
            return
        end

        local targetId = tonumber(args[2])
        if not targetId then
            guihooks.trigger('Message', {
                msg = "Error: playerId must be a number",
                ttl = 3,
                icon = 'error'
            })
            return
        end

        if TriggerServerEvent then
            TriggerServerEvent("PropHunt_TagRequest", tostring(targetId))
            guihooks.trigger('Message', {
                msg = "Tag request sent for player " .. tostring(targetId),
                ttl = 2,
                icon = 'near_me'
            })
        else
            guihooks.trigger('Message', {
                msg = "Error: TriggerServerEvent not available",
                ttl = 3,
                icon = 'error'
            })
        end

  elseif cmd == "/phhelp" then
        guihooks.trigger('Message', {
            msg = "PropHunt Commands:\n" ..
                  "/phconfig <setting> <value> - Configure client distances\n" ..
                  "Settings: taunt_dist, flash_dist, flash_cooldown, flash_effect_dist\n" ..
                  "/phtag <playerId> - (seekers) tag a hider (temporary until automatic tagging)",
            ttl = 9,
            icon = 'help'
        })
    end
end

-- --- EXPORTS ---
M.onExtensionLoaded = onExtensionLoaded
M.onUpdate = onUpdate
M.onChatMessage = onChatMessage
M.setRunner = setRunner
M.setProp = setProp
M.performSwap = performSwap
M.manualTaunt = manualTaunt
M.playSound = playSound
M.getPropID = function() return propID end


-- =============================
-- COLLISION TAGGING (Seeker)
-- =============================
local function resolveOwnerPlayerIdFromVehId(vehId)
    -- BeamMP APIs vary by version; attempt a few known/likely shapes.
    -- If none exist, return nil (and we can fall back to manual /phtag).
    if not vehId then return nil end

    local candidates = {
        function()
            if MPVehicleGE and MPVehicleGE.getOwnerID then return MPVehicleGE.getOwnerID(vehId) end
        end,
        function()
            if MPVehicleGE and MPVehicleGE.getVehicleOwner then return MPVehicleGE.getVehicleOwner(vehId) end
        end,
        function()
            if MPVehicleGE and MPVehicleGE.getOwner then return MPVehicleGE.getOwner(vehId) end
        end,
        function()
            if MPGameNetwork and MPGameNetwork.getVehicleOwner then return MPGameNetwork.getVehicleOwner(vehId) end
        end,
    }

    for _, fn in ipairs(candidates) do
        local ok, res = pcall(fn)
        if ok and res ~= nil then
            local n = tonumber(res)
            if n then return n end
        end
    end

    return nil
end

local lastAutoTagTime = 0
local AUTO_TAG_COOLDOWN = 0.5

local function onSeekerCollision(otherVehId)
    if not gameActive or hidePhase then return end
    if playerTeam ~= "seeker" then return end

    local t = os.clock()
    if (t - lastAutoTagTime) < AUTO_TAG_COOLDOWN then return end
    lastAutoTagTime = t

    local otherId = tonumber(otherVehId)
    if not otherId then return end

    local targetPlayerId = resolveOwnerPlayerIdFromVehId(otherId)
    if not targetPlayerId then
        -- No mapping available; keep quiet to avoid spam.
        -- Users can still use /phtag.
        print("DEBUG: Could not resolve owner for collided vehicle " .. tostring(otherId) .. " (BeamMP API mismatch)")
        return
    end

    if TriggerServerEvent then
        TriggerServerEvent("PropHunt_TagRequest", tostring(targetPlayerId))
        print("DEBUG: Auto-tag collision => requested tag on player " .. tostring(targetPlayerId))
    end
end

-- =============================
-- HIDER DISGUISE (BeamNG props)
-- =============================
local assignedPropName = nil
local attachedPropObjId = nil

local function deleteAttachedProp()
    if attachedPropObjId then
        local obj = scenetree.findObjectById(attachedPropObjId)
        if obj then obj:delete() end
    end
    attachedPropObjId = nil
end

local function tryHideVehicle(veh, hide)
    -- Best-effort: BeamNG API varies. We'll try a few possibilities.
    if not veh then return end

    -- Some versions expose mesh alpha via vehicleBridge action
    if core_vehicleBridge and core_vehicleBridge.executeAction then
        pcall(function()
            -- Not guaranteed to exist; if it does, 0=hidden, 1=visible
            core_vehicleBridge.executeAction(veh, 'setMeshAlpha', hide and 0 or 1)
        end)
    end

    -- Fallback: dim lights / reduce visibility a bit
    pcall(function()
        if hide then
            veh:queueLuaCommand("electrics.values.lights = 0")
        end
    end)
end

local function spawnAndAttachProp(propName)
    -- Revised: BeamNG "props" here are actually Prop vehicles (Type == 'Prop')
    -- so we disguise by replacing the player's vehicle with the prop vehicle.
    -- Example snippet provided uses: core_vehicles.replaceVehicle(chosenVehicle.key, {})

    deleteAttachedProp() -- legacy object-based disguise; no longer used

    if not core_vehicles or not core_vehicles.replaceVehicle then
        guihooks.trigger('Message', { msg = "Prop disguise failed: core_vehicles.replaceVehicle not available", ttl = 4, icon = 'error' })
        print("ERROR: core_vehicles.replaceVehicle not available")
        return
    end

    local function pickRandomPropConfig(modelKey)
        if not core_vehicles or not core_vehicles.getConfigList then return nil end
        local ok, list = pcall(function() return core_vehicles.getConfigList(true) end)
        if not ok or not list or not list.configs then return nil end

        local configs = {}
        for _, v in pairs(list.configs) do
            if v.model_key == modelKey then
                table.insert(configs, v)
            end
        end
        if #configs == 0 then return nil end

        local c = configs[math.random(#configs)]
        return c and c.key or nil
    end

    local cfgKey = pickRandomPropConfig(propName)

    local ok, err = pcall(function()
        if cfgKey then
            core_vehicles.replaceVehicle(propName, { config = cfgKey })
        else
            core_vehicles.replaceVehicle(propName, {})
        end
    end)

    if ok then
        guihooks.trigger('Message', { msg = "Disguised as prop: " .. tostring(propName), ttl = 4, icon = 'local_shipping' })
        print("DEBUG: Replaced vehicle with prop: " .. tostring(propName))
    else
        guihooks.trigger('Message', { msg = "Prop disguise failed: " .. tostring(propName), ttl = 4, icon = 'error' })
        print("ERROR: Failed to replace vehicle with prop '" .. tostring(propName) .. "': " .. tostring(err))
    end
end

local function updateAttachedPropTransform()
    -- legacy: object-attached props; no longer used
end

onAssignProp = function(data)
    assignedPropName = tostring(data or "")
    if assignedPropName == "" then return end

    -- Store immediately; the event order from server is not guaranteed.
    -- If this arrives before PropHunt_GameStart, we will apply disguise once team is known.
    guihooks.trigger('Message', { msg = "Prop assigned: " .. assignedPropName, ttl = 4, icon = 'local_shipping' })

    if playerTeam == "hider" then
        spawnAndAttachProp(assignedPropName)
    else
        print("DEBUG: Prop assigned but team not yet 'hider' (team=" .. tostring(playerTeam) .. "), deferring disguise")
    end
end

-- Export a callable so we can trigger from UI/keybind later if desired
M.onSeekerCollision = onSeekerCollision

M.manualFlashSound = manualFlashSound
return M